@page "/reports"
@using System.Net
@using System.Text.Json
@using Microsoft.AspNetCore.Authorization
@using Microsoft.AspNetCore.Identity
@using NetDeviceManager.Database.Identity
@using NetDeviceManager.Lib.Extensions
@using NetDeviceManager.Lib.GlobalConstantsAndEnums
@attribute [Authorize]
@rendermode InteractiveServer
<PageTitle>Reports</PageTitle>
<div>
    <h2>Reports for download</h2>

    <Grid @ref="grid"
          TItem="string"
          Class="table table-hover table-bordered table-striped"
          DataProvider="ReportsDataProvider"
          Responsive="true">

        <GridColumn TItem="string" HeaderText="Reports" PropertyName="ReportDate">
            @context
        </GridColumn>
        <GridColumn TItem="string" HeaderText="Action" PropertyName="action">
            <div style="display: flex; width: 100%; flex-direction: row-reverse;">
                <div class="btn-container-grid">
                    <button class="btn-style-normal btn-action font-16" @onclick="() => DownloadFile(context)">Download</button>
                </div>
            </div>

        </GridColumn>
    </Grid>


</div>

<style>
    .filter-form {
        display: flex;
        align-items: flex-end;
        margin-bottom: 8px;
    }
</style>

@code{
    
    BlazorBootstrap.Grid<string> grid = default!;
    
    [Inject] public HttpClient ApiClient { get; set; }
    [Inject] public UserManager<ApplicationUser> UserManager { get; set; }
    [Inject] public IHttpContextAccessor Accessor { get; set; }
    private string? _key = string.Empty;
    private IEnumerable<string> _reports = default!;
    [Inject] public IConfiguration Configuration { get; set; }
    [Inject] public IJSRuntime JS { get; set; }
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await base.OnAfterRenderAsync(firstRender);
        if (Accessor.HttpContext?.User != null)
            _key = UserManager.GetUserAsync(Accessor.HttpContext.User).Result?.ApiKey;
        if(!ApiClient.DefaultRequestHeaders.Contains(ApiConstants.ApiKey))
            ApiClient.DefaultRequestHeaders.Add(ApiConstants.ApiKey, _key);
        if (firstRender)
        {
            await grid.RefreshDataAsync();
        }
    }

    private async Task<GridDataProviderResult<string>> ReportsDataProvider(GridDataProviderRequest<string> request)
    {
        var host = Configuration["ApiHost"];
        var uri = new Uri($"http://{host}/{ApiConstants.EndpointGetReportsList}");
        _reports = await ApiClient.GetFromJsonAsync<string[]>(uri) ?? new string[] { };
        return await Task.FromResult(request.ApplyTo(_reports));
    }
    
    private async Task DownloadFile(string name)
    {
        var host = Configuration["ApiHost"];
        var apiUrl = $"http://{host}/{ApiConstants.EndpointGetReport}?id={name}";
        var destinationFilePath = name;

        try
        {
            //get file from api
            var response = await ApiClient.GetAsync(apiUrl, HttpCompletionOption.ResponseHeadersRead);
            
            //if request is successfully completed than download the file to client disk
            if (response.IsSuccessStatusCode)
            {
                //read file as byte array from the response
                var fileBytes = await response.Content.ReadAsByteArrayAsync();

                //create in memory stream from downloaded bytes
                using var streamRef = new DotNetStreamReference(new MemoryStream(fileBytes));
                
                //invoke js script that triggers browser file saving window
                await JS.InvokeVoidAsync("downloadFileFromStream", destinationFilePath, streamRef);
            }
            else
            {
                Console.WriteLine("Failed to download file. Status code: " + response.StatusCode);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine("An error occurred while downloading the file: " + ex.Message);
        }
    }
}